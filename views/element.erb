<script type="text/javascript" src="../jquery-1.10.2.min.js"></script>

<script>
	$(document).ready(function() {
		console.log("Running jQuery"); // debugging
		$origin_terms = $('#origin').find('.terms'); // get terms (orbitals, e.g. 3s2) in origin element

		// When user hovers mouse over an adjacent element, highlight the electron terms compared to the origin element
		$('#above, #left, #right, #below').hover(
			// On mouseover adjacent element
			function() {
				$adj_terms = $(this).find('.terms'); // get terms (orbitals, e.g. 4f10) in adjacent element
				$adj_terms.children().each(function() { // for each orbital term in adjacent element
					adj_term = $(this).text().replace(/\s/g, ''); // e.g., 4f10 [format: nlc where c = electron count]
					adj_n  = adj_term.charAt(0); // extract n quantum number (1, 2, 3,...) from term
					adj_l = adj_term.charAt(1); // extract l letter (s, p, d, or f) from term
					adj_count  = adj_term.substring(2,adj_term.length); // extract electron count (1-14) from term
					same_l_selector = 'span[class^="ec_"][class$="' + adj_l + '"]'; // jQuery selector for term in origin
					$same_l_in_origin = $origin_terms.find(same_l_selector); // jQuery object: analogous term in origin, e.g. 4f9 (will test to see if exists below)
					same_l = $same_l_in_origin.text().replace(/\s/g, ''); // text of analogous term in origin
					origin_n = same_l.charAt(0); // origin's principal quantum number, n, for this term
					origin_count  = same_l.substring(2,same_l.length); // extract electron count (1-14) from term					

					// If origin doesn't contain term with this l, highlight whole term in adjacent element
					origin_terms_text = $origin_terms.text().replace(/\s/g, '');
					// Mash-together of all terms in origin, e.g. 6s24f9. So can check one string to see if origin has term with same l value as current term of adjacent element.

					origin_has_term = origin_terms_text.indexOf(adj_l) != -1
					if (!origin_has_term) { // if origin doesn't contain term with this l, highlight whole term in adjacent element
						$(this).addClass('new_orbital');
						return true; // skip rest of highlighting rules for this term: whole term is highlighted because new
					}

					// If n value (for same l term) is different (adj vs. origin), highlight n value in both elements
					if(adj_n != origin_n) {
						$same_l_in_origin.find('span[class^="ec_"][class$="n"]').addClass('diff_n');
						$(this).find('span[class^="ec_"][class$="n"]').addClass('diff_n');
					}
					
					// If n and l values are same but electron count is different (adj vs. origin), highlight counts in both elements
					if(adj_count != origin_count) {
						$same_l_in_origin.find('span[class^="ec_"][class$="c"]').find('sup').addClass('diff_count');
						$(this).find('span[class^="ec_"][class$="c"]').find('sup').addClass('diff_count');
					}
					
				}) // end $adj_terms.children().each
				$origin_terms.children().each(function() { // for each orbital term in origin element
					origin_term = $(this).text().replace(/\s/g, ''); // get the text of the origin term, e.g. 4f10
					origin_l = origin_term.charAt(1); // extract l letter (s, p, d, or f) from term
					adj_ec_text = $adj_terms.text().replace(/\s/g, '');
					adj_has_term = adj_ec_text.indexOf(origin_l) != -1
					if (!adj_has_term) { // if adj element doesn't contain term with this l, highlight whole term in origin element
						$(this).addClass('new_orbital');
					}
				}) // end $origin_terms.children().each
			// On mouseout adjacent element,
			}, function() { // Remove all highlighting of orbital(s) (and parts thereof) on adjacent and origin elements
				$adj_terms.find('*').removeClass('new_orbital diff_n diff_count');
				$origin_terms.find('*').removeClass('new_orbital diff_n diff_count');
 			}
		);

	}); // end ready
</script>

<% @ec_class = "wide" #in pt_element.erb, specify electron config style: big text so can see what's highlighted %>

<!-- Database queries to find four adjacent elements. If one doesn't exist, flagged as such to modify table structure. -->
<% begin %>
	<% @above = Element.all(:period => @origin.period-1, :group => @origin.group)[0] %>
	<% above_exists = true if @above.atomic_num # OK if there is an element above origin; will go to rescue if not %>
<% rescue %>
	<% above_exists = false %>
<% end %>

<% begin %>
	<% @left = Element.all(:period => @origin.period, :group.lt => @origin.group, :order => [ :group.desc ], :limit => 1)[0] %>
	<% left_exists = true if @left.atomic_num # OK if there is an element left of origin; will go to rescue if not %>
<% rescue %>
	<% left_exists = false %>
<% end %>

<% begin %>
	<% @right = Element.all(:period => @origin.period, :group.gt => @origin.group, :order => [ :group.asc ], :limit => 1)[0] %>
	<% right_exists = true if @right.atomic_num # OK if there is an element right of origin; will go to rescue if not %>
<% rescue %>
	<% right_exists = false %>
<% end %>

<% begin %>
	<% @below = Element.all(:period => @origin.period+1, :group => @origin.group)[0] %>
	<% below_exists = true if @below.atomic_num # OK if there is an element below origin; will go to rescue if not %>
<% rescue %>
	<% below_exists = false %>
<% end %>

<table class="element">
        <tr><!-- Row for group headers -->
	        <% @link = Hash["type" => 'group'] %>
			<th>Group</th>
			<% if left_exists %>
				<th class="left_col">		
					<% group_entity = group_lin_to_trad(@left.group) %>
					<% if group_entity["type"]=="f" %>
						<% @link["text"] = group_entity["type"] + group_entity["num"].to_s %>			
					<% end %>
					<% @link["number"] = group_entity["num"] %>
					<%= erb :link_generator %>
				</th>
			<% end %>
			<th class="origin_col">
				<% group_entity = group_lin_to_trad(@origin.group) %>
				<% if group_entity["type"]=="f" %>
					<% @link["text"] = group_entity["type"] + group_entity["num"].to_s %>			
				<% end %>
				<% @link["number"] = group_entity["num"] %>
				<%= erb :link_generator %>
			</th>
			<% if right_exists %>
				<th class="right_col">
					<% group_entity = group_lin_to_trad(@right.group) %>
					<% if group_entity["type"]=="f" %>
						<% @link["text"] = group_entity["type"] + group_entity["num"].to_s %>			
					<% end %>
					<% @link["number"] = group_entity["num"] %>
					<%= erb :link_generator %>
				</th>
			<% end %>
        </tr>
        <tr>
                <th class="period_header">
                        Period<br>
				        <% @link["type"] = 'period' %>                        
        <!-- For element above origin element -->
                        <% if above_exists %>
							<% @link["number"] = @origin.period-1 %>
							<%= erb :link_generator %>
                </th>
                
                <!-- Row for element above origin-->
                        <% if left_exists %>
                                <td class="left_col"></td>
                        <% end %>
                        <td id="above" class="inPTable origin_col">
							<% @element = @above %>
							<%= erb :pt_element %>
                        </td>
                        <% if right_exists %>
                                <td class="right_col"></td>
                        <% end %>
                </tr>
                <tr>
                        <th class="period_header">
                        <% end %>
		<!-- Row for left, origin, right elements-->
				<% @link["number"] = @origin.period %>
				<%= erb :link_generator %>
			</th>
	
		<% if left_exists %>
			<td id="left" class="inPTable left_col">
				<!-- For element to the left of origin element -->
				<% @element = @left %>
				<%= erb :pt_element %>
			</td>
		<% end %>
		<td id="origin" class="inPTable origin origin_col">
			<!-- For origin element -->
				<% @element = @origin %>
				<%= erb :pt_element %><br>
				<span class="pt_name_origin">Name origin: <%= @element.name_origin %></span><br>
				<!--span class="pt_group">group: <%= @element.group %></span><br>
				<span class="pt_period">period: <%= @element.period %></span><br-->
				<span class="pt_atomic_weight">Atomic weight: 
					<% if @element.atomic_wt_is_mass_number_of_longest_lived_isotope == 1 %>
						[<%= @element.atomic_weight.round %>]
					<% else %>
						<%= @element.atomic_weight %>
					<% end %>
				</span><br>
				<!--span class="pt_atomic_wt_is_mass_number_of_longest_lived_isotope">atomic_wt_is_mass_number_of_longest_lived_isotope: <%= @element.atomic_wt_is_mass_number_of_longest_lived_isotope %></span><br-->
				<span class="pt_specific_heat_capacity_J_per_gK">Specific heat capacity: <%= @element.specific_heat_capacity_j_per_gk %> J/gK</span><br>
				<span class="pt_density_g_per_cm3">Density: 
					<% if @element.density_is_estimated == 1 %>
						(<%= @element.density_g_per_cm3.round %>)
					<% else %>
						<%= @element.density_g_per_cm3 %>
					<% end %>
					g/cm<sup>3</sup>
				</span><br>
				<!--span class="pt_density_is_estimated">density_is_estimated: <%= @element.density_is_estimated %></span><br-->
				<span class="pt_melting_point_k">Melting point: 
					<% if @element.melt_is_estimated == 1 %>
						(<%= @element.melting_point_k.round %>)
					<% else %>
						<%= @element.melting_point_k %>
					<% end %>
					 K		
				</span><br>
				<!--span class="pt_melt_is_estimated">melt_is_estimated: <%= @element.melt_is_estimated %></span><br-->
				<span class="pt_boiling_point_k">Boiling point: 
					<% if @element.boil_is_estimated == 1 %>
						(<%= @element.boiling_point_k.round %>)
					<% else %>
						<%= @element.boiling_point_k %>
					<% end %>			
					 K		
				</span><br>				
				<!--span class="pt_boil_is_estimated">boil_is_estimated: <%= @element.boil_is_estimated %></span><br-->
				<span class="pt_electronegativity">Electronegativity (Pauling): 
					<% if @element.electronegativity.nil? %>
						unknown
					<% else %>
						<%= @element.electronegativity %>
					<% end %>									
				</span><br>
				<span class="pt_abundance_mg_per_kg">Abundance: 
					<% if @element.abundance_is_upper_limit == 1 %>
						<
					<% end %>
					<%= @element.abundance_mg_per_kg %>
					 mg/kg
				</span><br>
				<!--span class="pt_"abundance_is_upper_limit">abundance_is_upper_limit: <%= @element.abundance_is_upper_limit %></span><br-->
				<!--span class="pt_"e_config_valence">e_config_valence: <%= @element.e_config_valence %></span><br-->
		</td>
		<% if right_exists %>
			<td id="right" class="inPTable right_col">
				<!-- For element to the right of origin element -->
				<% @element = @right %>
				<%= erb :pt_element %>
			</td>
		<% end %>
	</tr>
	<% if below_exists %>
		<tr><!-- Row for element below origin-->
		
			<th class="period_header">
				<% @link["number"] = @origin.period+1 %>
				<%= erb :link_generator %>
			</th>

			<% if left_exists %>
				<td class="left_col"></td>
			<% end %>
			<td id="below" class="inPTable origin_col">
				<!-- For element below origin element -->
				<% @element = @below %>
				<%= erb :pt_element %>
			</td>
			<% if right_exists %>
				<td class="right_col"></td>
			<% end %>
		</tr>
	<% end %>
</table>