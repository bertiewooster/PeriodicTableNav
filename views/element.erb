<!-- Database queries to find four adjacent elements. If one doesn't exist, flagged as such to modify table structure. -->
<% begin %>
	<% @above = Element.all(:period => @origin.period-1, :group => @origin.group)[0] %>
	<% above_exists = true if @above.atomic_num # OK if there is an element above origin; will go to rescue if not %>
<% rescue %>
	<% above_exists = false %>
<% end %>

<% begin %>
	<% @left = Element.all(:period => @origin.period, :group.lt => @origin.group, :order => [ :group.desc ], :limit => 1)[0] %>
	<% left_exists = true if @left.atomic_num # OK if there is an element left of origin; will go to rescue if not %>
<% rescue %>
	<% left_exists = false %>
<% end %>

<% begin %>
	<% @right = Element.all(:period => @origin.period, :group.gt => @origin.group, :order => [ :group.asc ], :limit => 1)[0] %>
	<% right_exists = true if @right.atomic_num # OK if there is an element right of origin; will go to rescue if not %>
<% rescue %>
	<% right_exists = false %>
<% end %>

<% begin %>
	<% @below = Element.all(:period => @origin.period+1, :group => @origin.group)[0] %>
	<% below_exists = true if @below.atomic_num # OK if there is an element below origin; will go to rescue if not %>
<% rescue %>
	<% below_exists = false %>
<% end %>

<table class="element">
        <tr><!-- Row for group headers -->
			<th>Group</th>
			<% if left_exists %>
				<th class="left_col">
					<%= erb :'partials/group_link_generator', :locals=> {:linear_group => @left.group} %>
					<% @traditional_group %>
				</th>
			<% end %>
			<th class="origin_col">
				<%= erb :'partials/group_link_generator', :locals=> {:linear_group => @origin.group} %>
			</th>
			<% if right_exists %>
				<th class="right_col">
					<%= erb :'partials/group_link_generator', :locals=> {:linear_group => @right.group} %>
				</th>
			<% end %>
        </tr>
        <tr>
                <th class="period_header">
                        Period<br>
        <!-- For element above origin element -->
                        <% if above_exists %>
							<%= erb :'partials/link_generator', :locals=> {:link => Hash["type" => 'period','number'=>@origin.period-1]} %>
                </th>
                
                <!-- Row for element above origin-->
                        <% if left_exists %>
                                <td class="left_col"></td>
                        <% end %>
                        <td id="above" class="inPTable origin_col">
							<%= erb :'partials/pt_element', :locals=> {:element => @above, :ec_class => "wide"} %>
                        </td>
                        <% if right_exists %>
                                <td class="right_col"></td>
                        <% end %>
                </tr>
                <tr>
                        <th class="period_header">
                        <% end %>
		<!-- Row for left, origin, right elements-->
				<%= erb :'partials/link_generator', :locals=> {:link => Hash["type" => 'period','number'=>@origin.period]} %>
			</th>
	
		<% if left_exists %>
			<td id="left" class="inPTable left_col">
				<!-- For element to the left of origin element -->
				<%= erb :'partials/pt_element', :locals=> {:element => @left, :ec_class => "wide"} %>
			</td>
		<% end %>
		<td id="origin" class="inPTable origin origin_col">
			<!-- For origin element -->
				<% origin_properties = 		
				{"atomic_num"=>nil,
				"symbol"=>nil,
				"name"=>nil,
				"e_config" => {"base" => true, "space_terms" => true, "term_spans"=>true},
				"name_origin" => {"label" => true},
				"atomic_weight" => {"label" => true},
				"specific_heat_capacity_j_per_gk" => {"label" => true},
				"density_g_per_cm3" => {"label" => true},
				"melting_point_k" => {"label" => true},
				"boiling_point_k" => {"label" => true},
				"electronegativity" => {"label" => true},
				"abundance_mg_per_kg" => {"label" => true}} %>

				<%= erb :'partials/pt_element', :locals=> {:element => @origin, :properties=>origin_properties, :ec_class => "wide", :no_link => true} %>
		</td>
		<% if right_exists %>
			<td id="right" class="inPTable right_col">
				<!-- For element to the right of origin element -->
				<%= erb :'partials/pt_element', :locals=> {:element => @right, :ec_class => "wide"} %>
			</td>
		<% end %>
	</tr>
	<% if below_exists %>
		<tr><!-- Row for element below origin-->
		
			<th class="period_header">
				<%= erb :'partials/link_generator', :locals=> {:link => Hash["type" => 'period','number'=>@origin.period+1]} %>
			</th>

			<% if left_exists %>
				<td class="left_col"></td>
			<% end %>
			<td id="below" class="inPTable origin_col">
				<!-- For element below origin element -->
				<%= erb :'partials/pt_element', :locals=> {:element => @below, :ec_class => "wide"} %>
			</td>
			<% if right_exists %>
				<td class="right_col"></td>
			<% end %>
		</tr>
	<% end %>
</table>

<script type="text/javascript" src="../jquery-1.10.2.min.js"></script>

<script>
	$(document).ready(function() {
		console.log("Running jQuery"); // debugging
		$origin_terms = $('#origin').find('.terms'); // get terms (orbitals, e.g. 3s2) in origin element

		// When user hovers mouse over an adjacent element, highlight the electron terms compared to the origin element
		$('#above, #left, #right, #below').hover(
			// On mouseover adjacent element
			function() {
				$adj_terms = $(this).find('.terms'); // get terms (orbitals, e.g. 4f10) in adjacent element
				$adj_terms.children().each(function() { // for each orbital term in adjacent element
					adj_term = $(this).text().replace(/\s/g, ''); // e.g., 4f10 [format: nlc where c = electron count]
					adj_n  = adj_term.charAt(0); // extract n quantum number (1, 2, 3,...) from term
					adj_l = adj_term.charAt(1); // extract l letter (s, p, d, or f) from term
					adj_count  = adj_term.substring(2,adj_term.length); // extract electron count (1-14) from term
					same_l_selector = 'span[class^="ec_"][class$="' + adj_l + '"]'; // jQuery selector for term in origin
					$same_l_in_origin = $origin_terms.find(same_l_selector); // jQuery object: analogous term in origin, e.g. 4f9 (will test to see if exists below)
					same_l = $same_l_in_origin.text().replace(/\s/g, ''); // text of analogous term in origin
					origin_n = same_l.charAt(0); // origin's principal quantum number, n, for this term
					origin_count  = same_l.substring(2,same_l.length); // extract electron count (1-14) from term					

					// If origin doesn't contain term with this l, highlight whole term in adjacent element
					origin_terms_text = $origin_terms.text().replace(/\s/g, '');
					// Mash-together of all terms in origin, e.g. 6s24f9. So can check one string to see if origin has term with same l value as current term of adjacent element.

					origin_has_term = origin_terms_text.indexOf(adj_l) != -1
					if (!origin_has_term) { // if origin doesn't contain term with this l, highlight whole term in adjacent element
						$(this).addClass('new_orbital');
						return true; // skip rest of highlighting rules for this term: whole term is highlighted because new
					}

					// If n value (for same l term) is different (adj vs. origin), highlight n value in both elements
					if(adj_n != origin_n) {
						$same_l_in_origin.find('span[class^="ec_"][class$="n"]').addClass('diff_n');
						$(this).find('span[class^="ec_"][class$="n"]').addClass('diff_n');
					}
					
					// If n and l values are same but electron count is different (adj vs. origin), highlight counts in both elements
					if(adj_count != origin_count) {
						$same_l_in_origin.find('span[class^="ec_"][class$="c"]').find('sup').addClass('diff_count');
						$(this).find('span[class^="ec_"][class$="c"]').find('sup').addClass('diff_count');
					}
					
				}) // end $adj_terms.children().each
				$origin_terms.children().each(function() { // for each orbital term in origin element
					origin_term = $(this).text().replace(/\s/g, ''); // get the text of the origin term, e.g. 4f10
					origin_l = origin_term.charAt(1); // extract l letter (s, p, d, or f) from term
					adj_ec_text = $adj_terms.text().replace(/\s/g, '');
					adj_has_term = adj_ec_text.indexOf(origin_l) != -1
					if (!adj_has_term) { // if adj element doesn't contain term with this l, highlight whole term in origin element
						$(this).addClass('new_orbital');
					}
				}) // end $origin_terms.children().each
			// On mouseout adjacent element,
			}, function() { // Remove all highlighting of orbital(s) (and parts thereof) on adjacent and origin elements
				$adj_terms.find('*').removeClass('new_orbital diff_n diff_count');
				$origin_terms.find('*').removeClass('new_orbital diff_n diff_count');
 			}
		);

	}); // end ready
</script>